<!DOCTYPE html>
<!-- saved from url=(0048)https://www.kylepaulsen.com/stuff/audioSort.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width">
  <title>Sort Audio By Loudness</title>
</head>
<body>
    This will split audio into 'chunks' and sort them by loudness.<br><br>
    First set a chunk size:<br>
    Chunk size (in seconds): <input id="chunk" value="0.05"><br><br>
    Crossfade length (Needs to be less than Chunk size [less than 1/2 of chunk size for overlap]): <input id="cross" value="0.008333333333333333333333333333"><br><br>
    Mode:
    <select id="algorithmMode">
        <option value="xfadeOverlap">Crossfade (Favor Volume Order)</option>
        <option value="xfadeNoOverlap">Crossfade (Favor Original Sample Length)</option>
        <option value="noXfade">No Crossfade</option>
    </select>
    Now choose a file:<br>
    <input type="file" id="file"> OR <button id="rec" style="width: 200px;">Record from your microphone</button><br><br>
    <button id="play">Play Again</button><br><br>
    <button id="save">Save</button>

    <script>
        window.module = {};
    </script>
    <!-- https://github.com/mattdiamond/Recorderjs -->
    <script src="recorder.js"></script>
    <!-- https://github.com/Jam3/audiobuffer-to-wav -->
    <script src="index.js"></script>
    <script>
        // hack to get this commonjs module.
        const bufferToWav = module.exports;

        const $ = document.querySelector.bind(document);
        const fileSelect = $('#file');

        const ctx = new AudioContext();
        let sampleRate = 44100;

        //the root square of the average of the square of each value
        //inclusive start, exclusive end
        //assumes start < end
        function rootMeanSquare(data, start, end) {
            const length = end - start;
            let rms = 0;
            for (let t = start; t < end; t++) {
                const value = data[t];
                rms += value * value;
            }
            rms /= length;
            rms = Math.sqrt(rms);
            return rms;
        }

        function changePCM(data) {
            // just reverse it
            //data.reverse();

            // MLG BLAST IT
            // const len = data.length;
            // for (let x = 0; x < len; x++) {
            //     data[x] = data[x] * 10;
            // }

            // sort sections by loudness
            let chunkSize = parseFloat($('#chunk').value);
            if (isNaN(chunkSize) || chunkSize <= 0) {
                alert('invalid chunk size, setting to 0.05');
                chunkSize = 0.05;
            }
            let algorithmMode = document.querySelector('#algorithmMode').value;
            let crossfadeLength = parseFloat($('#cross').value);
            if (isNaN(crossfadeLength) || crossfadeLength <= 0) {
                alert('invalid crossfade size, setting to 0.02');
                crossfadeLength = 0.02;
            }
            let crossfadeSamples = Math.floor(crossfadeLength * sampleRate);
            let crossfadeInArray = [];
            for (let i=0; i<crossfadeSamples; i++) {
                crossfadeInArray.push(i/crossfadeSamples);
            }
            let crossfadeOutArray = crossfadeInArray.slice().reverse()
            const frames = [];
            const len = data.length;
            let v = 0;
            let chunkIndex = 0;
            while (v < len) {
                let start = Math.floor(chunkIndex * chunkSize * sampleRate);
                let end = Math.floor(start + chunkSize * sampleRate);
                let frameSize = end-start;
                if (end >= len) {
                    //abandon any leftover data that doesn't fit
                    break;
                }
                let rms = rootMeanSquare(data, start, end);
                frames.push({offset: v, loudness: rms, frameSize: frameSize});
                v = end;
                chunkIndex++;
            }
            if (algorithmMode === 'xfadeNoOverlap') {
                //remove the last frame so we know we have some data after the second to last frame for fading
                frames.pop();
            }
            frames.sort(function(a, b) {
                return a.loudness - b.loudness;
            });
            const newBuffer = new Float32Array(len);
            const numFrames = frames.length;
            if (algorithmMode === 'xfadeNoOverlap') {
                let i = 0;
                // special case for first frame
                const frame = frames[0];
                const offset = frame.offset;
                for (let w = 0; w < frame.frameSize; w++) {
                    newBuffer[i] = data[offset + w];
                    i++;
                }
                for (let x = 1; x < numFrames; x++) {
                    const frame = frames[x];
                    const prevframe = frames[x-1];
                    //crossfade
                    for (let y = 0; y < crossfadeSamples; y++) {
                        newBuffer[i] = data[frame.offset + y]*crossfadeInArray[y] + data[prevframe.offset + prevframe.frameSize + y]*crossfadeOutArray[y];
                        i++;
                    }
                    for (let z = crossfadeSamples; z < frame.frameSize; z++) {
                        newBuffer[i] = data[frame.offset + z];
                        i++;
                    }
                }
            } else if (algorithmMode === 'xfadeOverlap') {
                let i = 0;
                // special case for first frame
                const frame = frames[0];
                const offset = frame.offset;
                for (let v = 0; v < frame.frameSize-crossfadeSamples; v++) {
                    newBuffer[i] = data[offset + v];
                    i++;
                }
                for (let w = 1; w < numFrames-1; w++) {
                    const prevFrame = frames[w-1];
                    const frame = frames[w];
                    const nextFrame = frames[w-1];
                    // crossfade into frame and out of prev frame
                    for (let x = 0; x < crossfadeSamples; x++) {
                        newBuffer[i] = data[frame.offset + x]*crossfadeInArray[x] + data[prevFrame.offset + prevFrame.frameSize - crossfadeSamples + x]*crossfadeOutArray[x];
                        i++;
                    }
                    // frame
                    for (let y = crossfadeSamples; y < frame.frameSize-crossfadeSamples; y++) {
                        newBuffer[i] = data[frame.offset + y];
                        i++;
                    }
                }
            } else {
                let i = 0;
                for (let x = 0; x < numFrames; x++) {
                    const frame = frames[x];
                    const offset = frame.offset;
                    for (let z = 0; z < frame.frameSize; z++) {
                        newBuffer[i] = data[offset + z];
                        i++;
                    }
                }
            }
            data.set(newBuffer);
        }

        function processBuffer(buffer) {
            const leftChannelData = buffer.getChannelData(0);
            let rightChannelData;
            try {
                rightChannelData = buffer.getChannelData(1);
            } catch(e) {}

            changePCM(leftChannelData);
            if (rightChannelData) {
                changePCM(rightChannelData);
            }

            const sourceNode = ctx.createBufferSource();
            sourceNode.buffer = buffer;
            sourceNode.connect(ctx.destination);
            sourceNode.start();

            $('#save').onclick = function() {
                const wav = bufferToWav(buffer);
                const blob = new window.Blob([ new DataView(wav) ], {
                    type: 'audio/wav'
                });

                const url = window.URL.createObjectURL(blob);
                const anchor = document.createElement('a');
                anchor.href = url;
                anchor.download = 'audio.wav';
                anchor.click();
                window.URL.revokeObjectURL(url);
            };
        }

        let play = function() {
            alert('Choose a file first!');
        };

        fileSelect.addEventListener('change', function(e) {
            const file = e.target.files[0];
            sampleRate = 44100;
            const context = new OfflineAudioContext(2, 1, sampleRate);

            const reader = new FileReader();
            reader.onload = function(e) {
                play = function() {
                    context.decodeAudioData(e.target.result, processBuffer, function(err) {
                        console.log(err);
                    });
                };
                play();
            };
            reader.readAsArrayBuffer(file);
        });

        $('#play').addEventListener('click', function() {
            play();
        });

        let recordingState = 'stopped';
        let currentStream;
        let rec;
        const recordBtn = $('#rec');
        recordBtn.addEventListener('click', function() {
            if (recordingState === 'recording') {
                recordingState = 'stopped';
                currentStream.getTracks()[0].stop();
                recordBtn.textContent = 'Record from your microphone';
                rec.stop();
                rec.getBuffer(function(buffers) {
                    play = function() {
                        sampleRate = ctx.sampleRate;
                        var newBuffer = ctx.createBuffer(buffers.length, buffers[0].length, ctx.sampleRate);
                        for (let x = 0; x < buffers.length; x++) {
                            newBuffer.getChannelData(x).set(buffers[x]);
                        }
                        processBuffer(newBuffer);
                    };
                    play();
                });
            } else if (recordingState === 'stopped') {
                recordingState = 'prepairing';
                navigator.mediaDevices.getUserMedia({audio: true}).then(function(stream) {
                    currentStream = stream;
                    recordingState = 'recording';
                    recordBtn.textContent = 'Stop recording';
                    const source = ctx.createMediaStreamSource(stream);
                    rec = new Recorder(source);
                    rec.record();
                }).catch(function(e) {
                    console.log('Error recording!', e);
                    recordingState = 'stopped';
                });
            }
        });
    </script>
</body></html>